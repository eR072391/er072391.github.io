<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on er072391 Blog</title>
    
    
    
    <link>https://er072391.github.io/posts/</link>
    <description>Recent content in Posts on er072391 Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 21 Oct 2022 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://er072391.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>CTF Support</title>
      <link>https://er072391.github.io/posts/ctf-support/</link>
      <pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://er072391.github.io/posts/ctf-support/</guid>
      <description>
        
          
          
          
        
        
        
          CTF Support Page # このページはCTFを行なう際、役にたつツールなどをまとめています。
Pwn &amp;amp; Rev # GDB # GNUデバッガ(GDB)、GNUソフトウェア・システムで動く標準のデバッガ。
多くのUnix系システムで動作可能な移植性の高いデバッガであり、Ada/C言語/C++/Objective-C/Pascal/FORTRAN/FreeBASIC/Goといったプログラミング言語に対応している。
Radare2 # バイナリをリバースエンジニアリングおよび分析するための完全なフレームワーク。
コマンドラインから独立して使用できる以下の一連の小さなユーティリティで構成されている。
[radiff2] バイナリ差分抽出ツール [rabin2] readelf-lineのバイナリ情報抽出ツール [rafind2] バイトパターン検索ツール [rahash2] ハッシュ計算ツール [rarun2] プログラムの実行環境を指定して実行できるツール [rasm2] アセンブラ/逆アセンブラ retdec # 逆コンパイラ。
ELF/PE/Mach-O/COFF/AR(archive)/Intel HEX/生のマシンコードのファイル形式をサポートし、
Intel x86/ARM/MIPS/PIC32/PowerPCの32 bitのアーキテクチャに対応している。
C言語で記述されたファイルに出力が可能。
Ghidra # 米国国家安全保障局によって開発されたオープンソースリバースエンジニアリングツール。
GitHubで公開されている。Javaで記述されている。
Pwntools # GallopsledというCTFチームがPwnableを解く際に使用している、Pythonで書かれたCTFフレームワーク。
apktool # Androidアプリをリバースエンジニアリングするためのツール。
dex2jar # Androidの.dexやJavaの.classファイル用の解析ツール。
IDA Pro # 逆アセンブラ機能、デバッグ機能、デコンパイラ機能といった数多くの機能を完備したリバースエンジニアリングツール。
逆アセンブラのデファクトスタンダードである。コード間の関連性チェックやAPIコール等を利用してプログラムの自動分析を行なう。
Immunity Debugger # エクスプロイトの作成、マルウェアの解析、バイナリファイルのリバースエンジニアリングを行なうためのツール。関数のグラフ表示機能を備えたユーザーインターフェイス、ヒープ作成に特化して構築されたヒープ解析ツール。Python APIを基盤に、拡張が可能。
checksec # 実行可能ファイルのPIE/RELRO/Canaries/ASLRなどのセキュリティ機構をチェックするためのbashスクリプト。
rp(++) # PE/ELF/Mach-Oの実行ファイルおよびx86/x64/ARM/ARM64のアーキテクチャ用のROPガジェットファインダー。
Binary Exploitation Notes # バイナリエクスプロイトに関しての記述。
          
        
        </description>
    </item>
    
    <item>
      <title>DreamhackCTF-Web-Writeups</title>
      <link>https://er072391.github.io/posts/dreamhackctf-web-writeups/</link>
      <pubDate>Thu, 13 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://er072391.github.io/posts/dreamhackctf-web-writeups/</guid>
      <description>
        
          
          
          
        
        
        
          API Portal # ディレクトリ構成とそれぞれのファイルの簡単な説明です
. └── html ├── action │ ├── cheat │ │ ├── eval.php eval関数があるが、実行不可 │ │ ├── phpinfo.php phpinfo(2)の結果表示 │ │ └── read-file.php /etc/passwdファイルの内容のみ表示 │ ├── db │ │ ├── create.php keyパラメータの値をmd5したディレクトリ作成 │ │ ├── delete.php keyパラメータの値をmd5したディレクトリ削除 │ │ ├── list.php /tmp/api-portal/db下のディレクトリ表示 │ │ ├── read.php dbkeyとkeyパラメータで指定したvalueを表示 │ │ └── save.php dbkeyとkeyパラメータを指定してvalueを保存 │ ├── flag │ │ ├── _flag.php 変数flagにフラグ格納 │ │ └── flag.php ローカルからのPOSTリクエスト(mode,dbkey,key)でフラグ表示 │ ├── help.
          
        
        </description>
    </item>
    
    <item>
      <title>ELFの保護機能について</title>
      <link>https://er072391.github.io/posts/elf%E3%81%AE%E4%BF%9D%E8%AD%B7%E6%A9%9F%E8%83%BD%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6/</link>
      <pubDate>Mon, 10 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://er072391.github.io/posts/elf%E3%81%AE%E4%BF%9D%E8%AD%B7%E6%A9%9F%E8%83%BD%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6/</guid>
      <description>
        
          
          
          
        
        
        
          RELRO (RELocation Read Only) # RELROは、仮想アドレス空間内の.gotセクションを読み取り専用にするリンカによる対策技術。
一般的な関数のアドレス解決は、初回の関数の呼び出し時に行うが、RELROが有効の場合、実行ファイルのロード時にシンボルのアドレス解決を行い、.gotセクションを読み込み可能にする。そのため、GOT書き換え攻撃に対して有効である。
RELROは遅延バインドが有効な場合はPartial RELROが適用され、仮想アドレス空間内に.gotセクションとは別に読み書き可能な.got.pltへの書き換えを許してしまう。遅延バインドが無効の場合はFull RELROが適用され、.got.pltセクションは生成されず、データセグメント以外読み込み専用となる。Full RELROでは、.gotセクションへの書き込みができないのでGOT 書き換え攻撃は行えない。しかし、Full RELROは、ロード時に全てのシンボルのアドレス解決を行うので、実行時のオーバーヘッドが高くなる。
簡潔に # RELRO　メモリ上のデータのどの部分に対してReadOnly属性を付けるか決定する役割を持つ。No RELROとPartial RELROとFull RELROの３つが存在する。
No RELRO　メモリ上のどの部分に対してもReadOnly属性を付けない。
Partial RELRO　.gotセクションを読み込み専用にし、.got.pltセクションを読み書き可能にする。
Full RELRO　データセグメント以外読み込み専用となる。
No RELRO と Partial RELRO の場合、GOT書き換え攻撃が行える。
SSP (Stack Smashing Protection) # SSPは、関数呼び出し時にスタック領域内の変数とフレームポインタの間にcanaryという乱数を挿入し、関数の終了時にcanaryの値の書き換えの有無をチェックすることでStack-based Buffer Overflow攻撃を検知する対策技術である。canaryの値が書き換えられていた場合は、プログラムの実行を停止する。この対策技術は、適用対象のプログラムのコンパイル時に関数の先頭にcanaryを挿入する命令を挿入し、関数の末尾にcanaryの書き換えをチェックする命令を挿入する。SSPはGCCのバージョン4.1からデフォルトで適用される。
これらの検査コードは、ローカル変数に文字配列がない関数や、文字配列が８バイト未満である関数には挿入されない。デフォルトの文字配列の閾値は８バイトであり、GCCのオプションの--param ssp-buffer-size=Nオプションを用いて変更できる。また、全ての関数に検査コードを挿入する。-fstack-protector-allオプションも提供されている。なお、Ubuntuでは、バージョン10.10以降、デフォルトの文字列配列の閾値は４バイトとなっている。
簡潔に # スタック領域内の変数とフレームポインタの間にcanaryという乱数を挿入する。
関数の終了時にcanaryが書き換えられていた場合、プログラムを停止する。
スタックバッファオーバーフロー攻撃に対して有効な対策
PIE (Position Independent Executable) # PIEは、ASLR(Address Space Layout Randomaization)では行われないテキスト領域のランダマイズ化を実現する対策技術である。実行ファイルのアドレス参照を相対アドレスにすることで、その実行ファイルが仮想アドレス空間のどこに配置されても正常に実行できるようにする。PIEはASLRと併せて適用することで、テキスト領域、データ領域、ヒープ領域、スタック領域のベースアドレスがランダマイズ化されるので、ROPに代表されるコード再利用攻撃の緩和に一定の効果がある。PIEはGCCバージョン3.4から導入された。 簡潔に # 実行コード内のアドレス参照をすべて相対アドレスで行う。
PIEが有効だと、特定のアドレスを指定する攻撃の成功を困難にする。
メモリ上のどこに展開されても正常に実行できる。
Automatic Fortification # Automatic Fortificationはコンパイル時に、バッファオーバーフロー脆弱性の原因となりうるライブラリ関数を書き込み先のバッファの境界検査を行う安全な代替関数に置換する対策技術である。置換された関数によって、バッファオーバーフローを検出した場合、プログラムの実行を停止する。
          
        
        </description>
    </item>
    
    <item>
      <title>ImaginaryCTF-Web-Writeups</title>
      <link>https://er072391.github.io/posts/imaginaryctf-web-writeups/</link>
      <pubDate>Mon, 10 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://er072391.github.io/posts/imaginaryctf-web-writeups/</guid>
      <description>
        
          
          
          
        
        
        
          ImaginaryCTF Web[Wisdom] # ImaginaryCTFのWeb問のWriteupを書きます。
ソースコードはこちら
1	#!/usr/bin/env python3 2	from flask import Flask, render_template_string, request, Response 3	app = Flask(__name__) 4	init_config = {key:app.config[key] for key in app.config} 5	@app.route(&amp;#39;/&amp;#39;) 6	def index(): 7	return Response(open(__file__).read(), mimetype=&amp;#39;text/plain&amp;#39;) 8	@app.route(&amp;#39;/docker&amp;#39;) 9	def docker(): 10	return Response(open(&amp;#34;Dockerfile&amp;#34;).read(), mimetype=&amp;#39;text/plain&amp;#39;) 11	@app.route(&amp;#39;/ssti&amp;#39;) 12	def ssti(): 13	query = request.args[&amp;#39;query&amp;#39;] if &amp;#39;query&amp;#39; in request.args else &amp;#39;...&amp;#39; 14	# no persistence! 15	to_del = [] 16	for key in app.
          
        
        </description>
    </item>
    
  </channel>
</rss>